# 01. 함수형 프로그래밍이란?

## 함수형 프로그래밍의 특징

함수형 프로그래밍은 프로그래밍 패러다임 중 하나이다. 데이터에 대한 처리를 수학적 함수의 조합으로 표현하고 문제를 함수 호출과 데이터 변환을 통해 해결한다.

아래는 함수형 프로그래밍의 특징이다.

* 불변성 (Immutable)
* 참조 투명성 (Referential transparency)
* 일급 함수 (First-class function)
* 게으른 평가 (Lazy evaluation)

함수형 프로그래밍을 활용하면 아래와 같은 이점을 얻을 수 있다.

* 부수효과가 없는 프로그램을 만들 수 있다. 부수 효과가 없기 때문에 공유 자원 사용에 유의해야 하는 동시성 프로그래밍에서 이점을 발휘할 수 있다.
* 코드의 복잡도를 낮추고 간결한 코드를 만들 수 있다.

## 코틀린에서 함수형 프로그래밍

코틀린은 다중 패러다임을 지원하는 언어이다. 객체지향 프로그래밍과과 동시에 함수형 프로그래밍 또한 지원하고 있다.
함수형을 완벽하게 지원 하는 아니지만 개념을 가져온 부분이 존재한다.

코틀린에서 함수형 프로그래밍과 같은 표현 방식을 적극 활용한다면 코드의 가독성은 더불어 병렬 처리에서도 이점을 가져올 수 있다.

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

val doubledNumbers = numbers.map { it * 2 }
```

## 순수 함수

순수 함수를 달성 하기 위해서는 다음 두 가지 조건을 만족해야 한다.

* 동일한 입력에 동일한 출력을 반환한다.
* 함수의 실행 도중 함수 외부의 상태를 변경하지 않는다.

아래는 순수 함수의 간단한 예시이다.

```kotlin
fun sum(x: Int, y: Int): Int = x + y
```

위 코드가 두 가지 조건을 만족하는지 확인해보자.

```kotlin
@Test
fun `동일한 입력에 동일한 출력을 반환한다`() {
    val result1 = sum(1, 2)
    val result2 = sum(1, 2)

    assertThat(result1).isEqualTo(result2)
}

@Test
fun `함수의 실행 도중 함수 외부의 상태를 변경하지 않는다`() {
    val x = 1
    val y = 2
    val z = 3

    val result = sum(x, y)

    assertThat(result).isEqualTo(3)
    assertThat(z).isEqualTo(3)
}
```

아래는 순수 하지 못한 함수의 예시이다.

```kotlin
var z = 3
fun impureSum(x: Int, y: Int) = x + y + z
```

`impureSum`은 외부 공유 자원인 `z`에 의존하고 있는 형태이다. 

그렇기 때문에 순수 함수는 기본적으로 부수효과를 가지고 있지 않다. 여기서 부수 효과는 `함수의 실행 도중 외부 상태를 변경`하거나 `외부 동작을 수행`하는 것을 의미한다.
단순히 전역 변수를 사용하지 않는다고 부수 효과가 제어되는 것은 아니다. 데이터베이스에서 데이터를 조회하는 것, 네트워크를 통해 다른 서버의 API를 호출하는 행위 등도 부수 효과가 될 수 있다.

순수 함수는 동일한 입력에 항상 동일한 결과를 반환해야 한다. 하지만 함수 내부에 외부 상태에 의존하는 코드가 있다는 것은 부수 효과를 가지고 있다는 말과 동일하다.
부수 효과는 프로그램에 대한 예측 가능성과 안정성을 해치는 그렇기 때문에 이러한 부수 효과를 없애거나 최소화하는 것이 바람직하다.

함수형 프로그래밍은 부수 효과를 최소화 하기 위해서 앞서 말한 순수 함수를 활용한다. 부수 효과가 발생하는 부분은 함수 수행 이후 외부에서 명시적으로 처리하거나
예외에 대한 부분도 값으로 판단하여 활용할 수 있도록 한다. 함수형에서 순수한 부분과 순수하지 않은 부분을 나누는 것이 굉장히 중요한 부분이다.

> 순수하지 않는 부분은 결국 부수 효과를 만들어내기 때문이다.

### 불변성 (immutable)

객체지향 관점에서 객체의 상태를 나타내는 필드를 수정하는 행위 조차도 어찌보면 부수 효과를 만들어낼 수 있다. 

아래는 통장을 나타내는 `PassBook`을 가변 형태로 작성한 것이다.

```kotlin
class MutablePassBook(
    var accountNumber: String,
    var balance: Long
) {

    fun transfer(money: Long) {
        this.balance -= money
    }
}
```

만약 `MutablePassBook`을 동시에 접근하여 `transfer()`를 통해 송금할 경우 변경 가능한 프로퍼티는 모두 `부수 효과`이다.

```kotlin
class ImmutablePassBook(
    val accountNumber: String,
    val balance: Long
) {

    fun transfer(money: Int): ImmutablePassBook = ImmutablePassBook(this.accountNumber, this.balance - money)
}

```

위와 같이 불변 프로퍼티를 활용하게 되면 부수 효과로 부터 안전해질 수 있다. 대신 매번 객체를 새롭게 생성해서 전달해야 하는 단점이 존재한다.

### 참조 투명성 (referential transparency)

참조 투명성은 프로그램의 변경 없이 어떤 표현식을 값으로 대체할 수 있는 것을 의미한다. 

> 수학에서 1 + 1을 2로 대체할 수 있다는 것이 참조 투명성을 의미한다.

참조 투명한 함수는 동일한 입력에 동일한 결과를 보장한다. 이러한 참조 투명성은 컴파일러가 결과를 추론할 수 있게 만든다. 
그렇기 때문에 런타임 시점이 아닌 컴파일 시점에 빠르게 결과를 추론할 수 있다. 

## 일급 객체(first-class object)와 일급 함수(first-class function)

`일급 객체(first-class object)`는 아래 세 가지 조건을 만족해야 한다.
 * `객체`를 함수의 매개변수로 넘길 수 있다.
 * `객체`를 함수의 반환값으로 돌려줄 수 있다.
 * `객체`를 변수나 자료구조에 담을 수 있다.

대부분의 객체지향 언어는 위 조건을 만족하는 일급 객체를 지원한다. 코틀린의 객체 또한 위 조건을 잘 지키고 있다.

`일급 함수(first-class function)`는 아래 세 가지 조건을 만족해야 한다.
 * `함수`를 함수의 매개변수로 넘길 수 있다.
 * `함수`를 함수의 반환값으로 돌려줄 수 있다.
 * `함수`를 변수나 자료구조에 담을 수 있다.

처음에 함수를 매개변수로 전달하고 반환값으로 활용하는 부분이 크게 와닿지 않았다. 단순하게 생각해보자. 
함수라는 행위 자체를 값으로 바라보고 전달한다고 생각하니 그제서야 이해가 되었다. 
java의 경우 애초에 메서드의 행위 자체를 전달할 수 있는 수단이 없기 때문에 익명 객체나 함수형 인터페이스를 통해 행위를 전달하는 수단을 제공하고 있다.
